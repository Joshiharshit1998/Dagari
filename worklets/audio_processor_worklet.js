class AudioProcessor extends AudioWorkletProcessor{constructor(){super(),this.port.onmessage=this.receive.bind(this),this.initialize()}initialize(){this.foundAudio=!1,this.recording=!1,this.chunks=[]}readChannelData(t,e=-1,a=9){let s;if(-1!==e){if(t[0]&&t[0].length-1<e)throw new Error(`Channel ${e} out of range: max ${t[0].length}`);s=e+1}else e=0,s=Math.min(t[0]?t[0].length:1,a);const n=[];for(let a=e;a<s;a++){const e=t.reduce(((t,e)=>t+e[a].length),0),s=t.map((t=>t[a])),r=new Float32Array(e);let o=0;for(let t=0;t<s.length;t++)r.set(s[t],o),o+=s[t].length;n[a]=r}return n}formatAudioData(t){if(1===t.length)return{float32Array:t[0].slice(),meanValues:t[0].slice()};{const e=new Float32Array(t[0].length*t.length),a=new Float32Array(t[0].length);for(let s=0;s<t[0].length;s++){const n=s*t.length;let r=0;for(let a=0;a<t.length;a++)e[n+a]=t[a][s],r+=t[a][s];a[s]=r/t.length}return{float32Array:e,meanValues:a}}}floatTo16BitPCM(t){const e=new ArrayBuffer(2*t.length),a=new DataView(e);let s=0;for(let e=0;e<t.length;e++,s+=2){let n=Math.max(-1,Math.min(1,t[e]));a.setInt16(s,n<0?32768*n:32767*n,!0)}return e}getValues(t=-1){const e=this.readChannelData(this.chunks,t),{meanValues:a}=this.formatAudioData(e);return{meanValues:a,channels:e}}export(){const t=this.readChannelData(this.chunks),{float32Array:e,meanValues:a}=this.formatAudioData(t);return{meanValues:a,audio:{bitsPerSample:16,channels:t,data:this.floatTo16BitPCM(e)}}}receive(t){const{event:e,id:a}=t.data;let s={};switch(e){case"start":this.recording=!0;break;case"stop":this.recording=!1;break;case"clear":this.initialize();break;case"export":s=this.export();break;case"read":s=this.getValues()}this.port.postMessage({event:"receipt",id:a,data:s})}sendChunk(t){const e=this.readChannelData([t]),{float32Array:a,meanValues:s}=this.formatAudioData(e),n=this.floatTo16BitPCM(a),r=this.floatTo16BitPCM(s);this.port.postMessage({event:"chunk",data:{mono:r,raw:n}})}process(t,e,a){const s=Math.min(t.length,e.length);for(let a=0;a<s;a++){const s=t[a],n=e[a],r=Math.min(s.length,n.length);for(let t=0;t<r;t++)s[t].forEach(((e,a)=>{n[t][a]=e}))}const n=t[0];let r=0;if(!this.foundAudio)for(const t of n){if(r=0,this.foundAudio)break;if(t)for(const e of t){if(0!==e){this.foundAudio=!0;break}r++}}if(n&&n[0]&&this.foundAudio&&this.recording){const t=n.map((t=>t.slice(r)));this.chunks.push(t),this.sendChunk(t)}return!0}}registerProcessor("audio_processor",AudioProcessor);