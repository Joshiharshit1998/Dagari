class AudioProcessor extends AudioWorkletProcessor{constructor(){super(),this.port.onmessage=this.receive.bind(this),this.initialize()}initialize(){this.foundAudio=!1,this.recording=!1,this.chunks=[]}readChannelData(t){let e,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:9;if(-1!==a){if(t[0]&&t[0].length-1<a)throw new Error(`Channel ${a} out of range: max ${t[0].length}`);e=a+1}else a=0,e=Math.min(t[0]?t[0].length:1,n);const s=[];for(let n=a;n<e;n++){const e=t.reduce(((t,e)=>t+e[n].length),0),a=t.map((t=>t[n])),o=new Float32Array(e);let r=0;for(let t=0;t<a.length;t++)o.set(a[t],r),r+=a[t].length;s[n]=o}return s}formatAudioData(t){if(1===t.length)return{float32Array:t[0].slice(),meanValues:t[0].slice()};{const e=new Float32Array(t[0].length*t.length),a=new Float32Array(t[0].length);for(let n=0;n<t[0].length;n++){const s=n*t.length;let o=0;for(let a=0;a<t.length;a++)e[s+a]=t[a][n],o+=t[a][n];a[n]=o/t.length}return{float32Array:e,meanValues:a}}}floatTo16BitPCM(t){const e=new ArrayBuffer(2*t.length),a=new DataView(e);let n=0;for(let e=0;e<t.length;e++,n+=2){let s=Math.max(-1,Math.min(1,t[e]));a.setInt16(n,s<0?32768*s:32767*s,!0)}return e}getValues(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;const e=this.readChannelData(this.chunks,t),{meanValues:a}=this.formatAudioData(e);return{meanValues:a,channels:e}}export(){const t=this.readChannelData(this.chunks),{float32Array:e,meanValues:a}=this.formatAudioData(t);return{meanValues:a,audio:{bitsPerSample:16,channels:t,data:this.floatTo16BitPCM(e)}}}receive(t){const{event:e,id:a}=t.data;let n={};switch(e){case"start":this.recording=!0;break;case"stop":this.recording=!1;break;case"clear":this.initialize();break;case"export":n=this.export();break;case"read":n=this.getValues()}this.port.postMessage({event:"receipt",id:a,data:n})}sendChunk(t){const e=this.readChannelData([t]),{float32Array:a,meanValues:n}=this.formatAudioData(e),s=this.floatTo16BitPCM(a),o=this.floatTo16BitPCM(n);this.port.postMessage({event:"chunk",data:{mono:o,raw:s}})}process(t,e,a){const n=Math.min(t.length,e.length);for(let a=0;a<n;a++){const n=t[a],s=e[a],o=Math.min(n.length,s.length);for(let t=0;t<o;t++)n[t].forEach(((e,a)=>{s[t][a]=e}))}const s=t[0];let o=0;if(!this.foundAudio)for(const t of s){if(o=0,this.foundAudio)break;if(t)for(const e of t){if(0!==e){this.foundAudio=!0;break}o++}}if(s&&s[0]&&this.foundAudio&&this.recording){const t=s.map((t=>t.slice(o)));this.chunks.push(t),this.sendChunk(t)}return!0}}registerProcessor("audio_processor",AudioProcessor);