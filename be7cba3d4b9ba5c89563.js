class StreamProcessor extends AudioWorkletProcessor{constructor(){super(),this.hasStarted=!1,this.hasInterrupted=!1,this.trackBuffers={},this.bufferLength=128,this.currentWrites={},this.trackSampleOffsets={},this.port.onmessage=t=>{if(t.data){const e=t.data;if("write"===e.event){const t=e.buffer,s=new Float32Array(t.length);for(let e=0;e<t.length;e++)s[e]=t[e]/32768;this.writeData(s,e.trackId)}else{if("offset"!==e.event&&"interrupt"!==e.event)throw new Error(`Unhandled event "${e.event}"`);{const t=e.requestId,s=Object.keys(this.trackSampleOffsets),r=s.length>0?s[s.length-1]:null,f=r&&this.trackSampleOffsets[r]||0;this.port.postMessage({event:"offset",requestId:t,trackId:r,offset:f}),"interrupt"===e.event&&(this.hasInterrupted=!0)}}}}}writeData(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";this.trackBuffers[e]||(this.trackBuffers[e]=[],this.currentWrites[e]={buffer:new Float32Array(this.bufferLength),offset:0});let{buffer:s,offset:r}=this.currentWrites[e];for(let f=0;f<t.length;f++)s[r++]=t[f],r>=s.length&&(this.trackBuffers[e].push(s),s=new Float32Array(this.bufferLength),r=0);return this.currentWrites[e].buffer=s,this.currentWrites[e].offset=r,!0}process(t,e,s){const r=e[0][0];if(this.hasInterrupted)return this.port.postMessage({event:"stop"}),!1;for(let t=0;t<r.length;t++)r[t]=0;let f=!1;for(const t in this.trackBuffers){const e=this.trackBuffers[t];if(e.length>0){f=!0,this.hasStarted=!0;const s=e.shift();for(let t=0;t<r.length&&t<s.length;t++)r[t]+=s[t];this.trackSampleOffsets[t]=this.trackSampleOffsets[t]||0,this.trackSampleOffsets[t]+=s.length}}for(const t in this.trackBuffers)0===this.trackBuffers[t].length&&(delete this.trackBuffers[t],delete this.currentWrites[t]);return!f&&this.hasStarted&&this.port.postMessage({event:"buffer-empty"}),!0}}registerProcessor("stream_processor",StreamProcessor);